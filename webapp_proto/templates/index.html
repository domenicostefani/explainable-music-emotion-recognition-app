<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explainable Music Emotion Recognition</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="icon" href="{{ url_for('static', filename='favicon.png') }}" type="image/x-icon">
    <style>
        /* Animation styles for gradual unveiling */
        .rev-box > * { /* Select level1 children of .rev-box */
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.8s ease-out, transform 0.8s ease-out;
        }
        
        .rev-box .unveiled {
            opacity: 1;
            transform: translateY(0);
        }
        
        .rev-box .instant {
            opacity: 1;
            transform: translateY(0);
            transition: none;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">Explainable Music Emotion Recognition</div>
        <a class="dark-mode-toggle" onclick="toggleDarkMode()">
            <span id="theme-icon">ðŸŒ™</span>
            <span id="theme-text">Dark Mode</span>
        </a>
    </header>

    <div class="container", style="text-align: center;">
        <p id="initialInfobox" {% if show_waveform %}style="display: none;"{% endif %}>
            {% if recording_supported %}
                Record or load
            {% else %}
                Load
            {% endif %}
            an audio file to analyze its emotional content.</p>
        <div class="controls">
            {% if recording_supported %}
                    <!-- <button id="newRecordingBtn" class="new-recording-btn">New Recording</button> -->
                        <button id="recordBtn" class="record-btn" {% if show_waveform %}style="display: none;"{% endif %}>Record</button>
            {% else %}
            {% endif %}
            <button id="loadBtn" class="load-btn"     {% if show_waveform %}style="display: none;"{% endif %}>Load Audio</button>
            <button id="stopBtn" class="record-btn" style="background-color: #666; display: none;">Stop</button>
            
        </div>

        <div class="loader-container-1" >
            <div class="loader"></div>
        </div>
        
        <div id="timer" style="font-size: 24px; font-weight: bold; margin: 10px 0; display: none;">
            Recording: <span id="timerDisplay">0.0s</span>
        </div>
        
        <div id="status" class="status"></div>
        
        
        <div id="waveformContainer" class="waveform-container">
            <!-- <h2>Recorded Waveform - Duration: <span id="waveformDuration"></span>s (Click on a section to zoom in)</h2> -->
            <!-- <div style="width:100%; overflow: scroll;"> -->
            <div class="rec-filename-display-box">
                <a id="recFilename" class="rec-filename-display"></a>
                {% if show_waveform %}
                <!-- <button id="newRecordingBtn" class="new-recording-btn">New Recording</button> -->
                <button id="clearBtn" class="clear-btn">Clear</button>
                {% else %}
                {% endif %}
            </div>
            
            <!-- <button onclick="resetAnimationState(); startGradualUnveiling()" class="start-animation-btn" id="startAnimationBtn" style="display: inline-block; background-color: #666;">
                <span>Start Animation</span>
            </button>
            <button onclick="console.log('resetting sessionstorage'); sessionStorage.clear(); location.reload()" class="start-animation-btn" style="display: inline-block; background-color: red;">
                <span>Reset cookies</span>
            </button> -->

            <div class="message-box rev-box" id="messageBox1">
                <p id="message">Nice song!</p>
                <p>We liked your song so much that we ran it through a <b>Neural Network</b> <a href="https://en.wikipedia.org/wiki/Neural_network_(machine_learning)" target="_blank">(what is that?)</a> that tries to understand its emotional content.</p>
                <p>The Artificial model only understands <i>extremes</i>: <b class="emocolor-darker-aggressive">Aggressiveness</b>, <b class="emocolor-darker-happy">Happiness</b>, <b class="emocolor-darker-relaxed">Relaxedness</b>, and <b class="emocolor-darker-sad">Sadness</b>.</p>

                <p>And the winner is... &#x1F941&#x1F941&#x1F941</p>
            </div>

            <div id="overallEmotion" class="overall-emotion rev-box">
                <p>Overall Emotion: <span id="overallEmotionText"></span></p>
            </div>

            
            <div class="message-box rev-box" id="messageBox2">
                <p>You can listen to it again to see whether you agree or not:</p>
            </div>
                
            <!-- </div> -->
            <div class="rev-box">
                <audio id="recPlayer" controls class="rec-player">
                    <source id="recSource" src="" type="audio/wav">
                    Your browser does not support the audio element.
                </audio>
            </div>

            <div class="message-box rev-box" id="dist-emo-infobox">
                <p>Want to know more about how shure the model was? Click the <b>Show Distribution</b> button below.
            </div>

            <div class="rev-box">
                <button class="show-distribution-btn" id="showDistributionBtn" onclick="showBarChart(this)">
                    <span>Show Distribution</span>
                </button>
            </div>

            <div class="bar-chart-container">
                <p><b>Emotion Distribution</b></p>
                <div class="bar-chart">
                    <div class="bar-item">
                        <div class="bar-label" id="bar_label_0">Emotion 1</div>
                        <div class="bar-background">
                            <div class="bar-fill emotion-0" id="bar_fill_0" style="width: 0%"></div>
                            <div class="bar-percentage" id="bar_percentage_0">0%</div>
                        </div>
                    </div>
                    <div class="bar-item">
                        <div class="bar-label" id="bar_label_1">Emotion 2</div>
                        <div class="bar-background">
                            <div class="bar-fill emotion-1" id="bar_fill_1" style="width: 0%"></div>
                            <div class="bar-percentage" id="bar_percentage_1">0%</div>
                        </div>
                    </div>
                    <div class="bar-item">
                        <div class="bar-label" id="bar_label_2">Emotion 3</div>
                        <div class="bar-background">
                            <div class="bar-fill emotion-2" id="bar_fill_2" style="width: 0%"></div>
                            <div class="bar-percentage" id="bar_percentage_2">0%</div>
                        </div>
                    </div>
                    <div class="bar-item">
                        <div class="bar-label" id="bar_label_3">Emotion 4</div>
                        <div class="bar-background">
                            <div class="bar-fill emotion-3" id="bar_fill_3" style="width: 0%"></div>
                            <div class="bar-percentage" id="bar_percentage_3">0%</div>
                        </div>
                    </div>
                </div>
            </div>

            
            <div class="message-box below-bar-chart" id="messageBox3">
                <p>But we can tell you more.</p>
                <p>
                    This AI model (the neural network) looks at pieces of 3 seconds of audio at a time, so we can show you what the model
                    thought about each part of the song.
                </p>
            </div>

            <button class="show-waveform-btn below-bar-chart" id="showWaveformBtn" onclick="unveilWaveform(this)">
                <span>Show Waveform</span>
            </button>

            
            <div id="sliceStatus" class="slice-status below-bar-chart below-waveform">
                <span id="sliceStatusText">Preparing slice views...</span>
            </div>
            <div class="chart-container below-bar-chart below-waveform">
                <div class="slice-overlay">
                    <img id="waveformImg" class="waveform-img" alt="Waveform">
                    <!-- Slice buttons will be added dynamically -->

                    <style>
                        .speech-balloon {
                            position: absolute;
                            top: 60%;
                            left: 10%;
                            background: #fff9d4;
                            border: 3px solid #333;
                            border-radius: 20px;
                            padding: 15px 20px;
                            font-size: 16px;
                            max-width: 20rem;
                            color: #333;
                            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
                            text-align: center;
                            z-index: 10;
                            animation: bounce 2s ease-in-out infinite;
                            cursor: pointer;
                        }

                        .speech-balloon::hover {
                            filter: brightness(80%);
                        }

                        /* Balloon tail/pointer */
                        /* .speech-balloon::after {
                            content: '';
                            position: absolute;
                            width: 0;
                            height: 0;
                            border-style: solid;
                        } */

                    </style>

                    <button class="speech-balloon center-balloon balloon-bottom-left" onclick="this.style.display='none'">
                        Click on any slice to get more info
                    </button>
                </div>
            </div>


                
            <div class="chart-container below-bar-chart below-waveform" id="emotionChartImgBox">
                <p>And since your song contains multiple slices, you can check out how the <b>model's confidence</b> changes <b>through time</b></p>
                <img id="emotionChartImg" class="waveform-img" alt="Emotion Chart">
            </div>


            
            <button class="show-slices-btn below-bar-chart below-waveform" id="showSlicesBtn" onclick="showSlices(this)">
                <span>I want to know more about the slices!</span>
            </button>
        </div>
    </div>

    <div class="footer">
        Made by <a href="https://github.com/michelerossi1" target="_blank">Michele Rossi</a> and <a href="https://domenicostefani.com/" target="_blank">Domenico Stefani</a> @ CIMIL, University of Trento, Italy.
    </div>

    <script src="{{ url_for('static', filename='js/darkmode.js') }}"></script>

    <script>
        // Animation control variables
        // let animationStarted = false;
        sessionStorage.setItem('animationStarted', 'false'); // Initialize animation state in sessionStorage
        let animationTimeouts = [];

        // if showSliceButtons is not a sessionStorage item, set it to false
        if (!sessionStorage.getItem('showSliceButtons')) {
            console.log('showSliceButtons not found in sessionStorage, setting to false');
            sessionStorage.setItem('showSliceButtons', 'false');
        }


        function clearAllAnimationTimeouts() {
            animationTimeouts.forEach(timeout => clearTimeout(timeout));
            animationTimeouts = [];
        }

        function resetAnimationState() {
            // animationStarted = false;
            sessionStorage.setItem('animationStarted', 'false');
            clearAllAnimationTimeouts();
            
            // Reset all paragraphs to hidden state
            document.querySelectorAll('.rev-box > *').forEach(p => {
                p.classList.remove('unveiled', 'instant');
            });
        }

        function startGradualUnveiling() {
            console.log('startGradualUnveiling called');
            const animationStarted = sessionStorage.getItem('animationStarted') === 'true';
            if (animationStarted) return;
            // animationStarted = true;
            sessionStorage.setItem('animationStarted', 'true');
            console.log('Starting gradual unveiling animation');
            let totalDelay = 0;

            // const messageBoxes = ['messageBox1', 'overallEmotion', 'messageBox2', 'dist-emo-infobox'];
            const revealableBoxes = document.querySelectorAll('.rev-box'); // Select all elements with class "rev-box"
            const messageBoxes = Array.from(revealableBoxes)

            messageBoxes.forEach((box, index) => {
                if (box && box.style.display !== 'none') {
                    // const paragraphs = box.querySelectorAll('p');
                    // console.log('Found', paragraphs.length, 'paragraphs in', boxId);

                    // Instead of paragraphs, select all level1 children of the box
                    const children = box.children; // Get all direct children of the box

                    // Log how many children were found and thefirst line of the html of the box
                    // console.log(`Found ${children.length} children in box ${box.id || index + 1}:`, box.outerHTML.split('\n')[0]);

                    // For each child, add the unveiled class with a delay
                    Array.from(children).forEach((child, index) => {
                        const timeout = setTimeout(() => {
                            child.classList.add('unveiled');
                        }, totalDelay);
                        animationTimeouts.push(timeout);
                        totalDelay += 1000; // 1 second intervals
                    });
                    
                    // paragraphs.forEach((p, index) => {
                    //     const timeout = setTimeout(() => {
                    //         p.classList.add('unveiled');
                    //     }, totalDelay);
                    //     animationTimeouts.push(timeout);
                    //     totalDelay += 3000; // 3 second intervals
                    // });
                }
            });
        }

        function showBarChart(elem) {
            console.log('Show Distribution button clicked');
            document.querySelector('.bar-chart-container').style.display = 'block';
            elem.style.display = 'none';
            document.getElementById('dist-emo-infobox').style.display = 'none';
            sessionStorage.setItem('showDistribution', 'true');
            document.querySelector('.bar-chart-container').scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Show all below-bar-chart elements
            const belowBarChartElements = document.querySelectorAll('.below-bar-chart');
            belowBarChartElements.forEach(el => {
                // show only if below-waveform is not part of the class
                if (!el.classList.contains('below-waveform')) {
                    el.style.display = 'block';
                    
                    // // If this is messageBox3, start its animation or show instantly
                    // if (el.id === 'messageBox3') {
                    //     const paragraphs = el.querySelectorAll('p');
                    //     if (animationStarted) {
                    //         // If main animation has started, show instantly
                    //         paragraphs.forEach(p => p.classList.add('instant'));
                    //     } else {
                    //         // If main animation hasn't started, it will be handled by the main animation
                    //     }
                    // }
                }
            });
        }

        function unveilWaveform(elem) {
            console.log('Show Waveform button clicked');
            document.querySelector('.slice-overlay').style.display = 'block';

            elem.style.display = 'none';
            sessionStorage.setItem('showWaveform', 'true');
            sessionStorage.setItem('showSliceButtons', 'false');
            document.querySelector('.slice-overlay').scrollIntoView({ behavior: 'smooth', block: 'center' });

            const slicesLength = sessionStorage.getItem('slicesLength');
            console.log('SessionStorage slicesLength:', slicesLength);
            const showPerSliceEmoChart = (slicesLength && parseInt(slicesLength) > 1) ? true : false;

            // Show all below-waveform elements, except for id "'emotionChartImgBox'" that is shown only if showPerSliceEmoChart is true
            document.querySelectorAll('.below-waveform').forEach(el => {
                if (el.id === 'emotionChartImgBox' && !showPerSliceEmoChart) {
                    el.style.display = 'none';
                } else {
                    el.style.display = 'block';
                }
                // el.style.display = 'block';
            });

            document.querySelectorAll('.slice-button').forEach(el => {
                el.style.display = 'none';
            });
            document.getElementById('sliceStatus').style.display = 'none';


            // if (slicesLength && parseInt(slicesLength) > 1) {
            //     if (sessionStorage.getItem('showWaveform') === 'true') {
            //         console.log('showWaveform is true, displaying emotion chart');
            //         emotionChartImgBox.style.display = 'block';
            //     } else {
            //         console.log('showWaveform is false, hiding emotion chart');
            //         emotionChartImgBox.style.display = 'none';
            //     }
            // }

        }

        // Handle initial state based on sessionStorage
        if (sessionStorage.getItem('showDistribution') === 'true') {
            console.log('showDistribution is true, showing bar chart');
            document.querySelector('.bar-chart-container').style.display = 'block';
            document.getElementById('showDistributionBtn').style.display = 'none';
            document.getElementById('dist-emo-infobox').style.display = 'none';

            // Show all elements with class "below-bar-chart"
            const belowBarChartElements = document.querySelectorAll('.below-bar-chart');
            belowBarChartElements.forEach(el => {
                el.style.display = 'block';
                
                // Show message box paragraphs instantly if they're visible
                if (el.classList.contains('rev-box')) {
                    // const paragraphs = el.querySelectorAll('p');
                    // paragraphs.forEach(p => p.classList.add('instant'));

                    // Add instant to ALL 1st level children of the box
                    Array.from(el.children).forEach(child => {
                        console.log('Adding instant class to child:', child);
                        child.classList.add('instant');
                    });
                }
            });
        } else {
            console.log('showDistribution is false, hiding bar chart');
            document.querySelector('.bar-chart-container').style.display = 'none';

            // hide all elements with class "below-bar-chart"
            const belowBarChartElements = document.querySelectorAll('.below-bar-chart');
            belowBarChartElements.forEach(el => {
                el.style.display = 'none';
            });
        }
        
        if (sessionStorage.getItem('showWaveform') === 'true') {
            console.log('showWaveform is true, showing waveform');
            document.querySelector('.slice-overlay').style.display = 'block';
            document.getElementById('showWaveformBtn').style.display = 'none';

            // Show all elements with class "below-waveform"
            document.querySelectorAll('.below-waveform').forEach(el => {
                el.style.display = 'block';
            });

            if (sessionStorage.getItem('showSliceButtons') === 'true') { // Show all slice buttons
                console.log('Showing slice buttons based on sessionStorage');
                document.querySelectorAll('.slice-button').forEach(el => { el.style.display = 'block'; });
                document.getElementById('sliceStatus').style.display = 'block';
                console.log('Hiding "show slices" button based on sessionStorage');
                document.getElementById('showSlicesBtn').style.display = 'none';
            } else { // Hide all slice buttons
                console.log('Hiding slice buttons based on sessionStorage');
                document.querySelectorAll('.slice-button').forEach(el => { el.style.display = 'none'; });
                document.getElementById('sliceStatus').style.display = 'none';
            }
        } else {
            console.log('showWaveform is false, hiding waveform');
            document.querySelector('.slice-overlay').style.display = 'none';
            // hide all elements with class "below-waveform"
            document.querySelectorAll('.below-waveform').forEach(el => {
                el.style.display = 'none';
            });
        }

        function showSlices(elem) {
            console.log('Show Slices button clicked');
            // Show all slice buttons

            console.log('Showing slice buttons');
            document.querySelectorAll('.slice-button').forEach(el => { el.style.display = 'block'; });
            document.getElementById('sliceStatus').style.display = 'block';

            // elem.style.display = 'none';
            console.log('Setting sessionStorage for showSliceButtons to true');
            sessionStorage.setItem('showSliceButtons', 'true');
            document.querySelector('.slice-overlay').scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        const messages = [
            "Nice song!",
            "Great improvisation!",
            "Wow!",
            "Amazing performance!",
            "Incredible talent!",
            "That was beautiful!",
            "Outstanding!",
            "Brilliant work!",
            "Absolutely stunning!",
            "What a masterpiece!",
            "Exceptional playing!",
            "Mind-blowing!",
            "Perfect execution!",
            "Truly inspiring!",
            "Absolutely magical!",
            "Phenomenal!",
            "That gave me chills!",
            "Pure artistry!",
            "Breathtaking!",
            "Absolutely incredible!",
            "That was flawless!",
            "Such emotion!",
            "Goosebumps!",
            "Spectacular!",
            "That touched my soul!",
            "Mesmerizing!",
            "Absolutely divine!",
            "What a gift!",
            "Legendary performance!",
            "That was pure magic!"
        ];

        function showRandomMessage() {
            const randomIndex = Math.floor(Math.random() * messages.length);
            document.getElementById('message').textContent = messages[randomIndex];
        }
        showRandomMessage();

        const initialInfobox = document.getElementById('initialInfobox');
        const recordBtn = document.getElementById('recordBtn');
        const loadBtn = document.getElementById('loadBtn');
        const stopBtn = document.getElementById('stopBtn');
        // const newRecordingBtn = document.getElementById('newRecordingBtn');
        const clearBtn = document.getElementById('clearBtn');
        const timer = document.getElementById('timer');
        const timerDisplay = document.getElementById('timerDisplay');
        const status = document.getElementById('status');
        const waveformContainer = document.getElementById('waveformContainer');
        const waveformImg = document.getElementById('waveformImg');
        const emotionChartImg = document.getElementById('emotionChartImg');
        const emotionChartImgBox = document.getElementById('emotionChartImgBox');
        const waveformDuration = document.getElementById('waveformDuration');
        const recFilename = document.getElementById('recFilename');
        const sliceStatus = document.getElementById('sliceStatus');
        const sliceStatusText = document.getElementById('sliceStatusText');
        const recPlayer = document.getElementById('recPlayer');
        const recSource = document.getElementById('recSource');
        const overallEmotionText = document.getElementById('overallEmotionText');
        const overallEmotionProbs = [
            document.getElementById('prob_emo0'),
            document.getElementById('prob_emo1'),
            document.getElementById('prob_emo2'),
            document.getElementById('prob_emo3')
        ];

        let isRecording = false;
        let timerInterval;
        let sliceStatusInterval;

        loadBtn.addEventListener('click', loadAudio);
        if (recordBtn)
            recordBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        // if (newRecordingBtn) {
        //     newRecordingBtn.addEventListener('click', startNewRecording);
        // }
        if (clearBtn) {
            clearBtn.addEventListener('click', clearRec);
        }

        function clearRec() {
            // Reset animation state when clearing
            resetAnimationState();
            
            // if (newRecordingBtn) newRecordingBtn.style.display = 'block';
            if (recordBtn)
                recordBtn.style.display = 'block';
            loadBtn.style.display = 'inline-block';
            initialInfobox.style.display = 'block';
            if (clearBtn) clearBtn.style.display = 'none';

            waveformContainer.style.display = 'none';
            status.style.display = 'none';
            sliceStatus.style.display = 'none';
            
            // Clear slice status interval
            if (sliceStatusInterval) {
                clearInterval(sliceStatusInterval);
                sliceStatusInterval = null;
            }

            fetch('/clear_waveform', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    console.log('Recording cleared:', data);
                });

            // ALso, reset sessionStorage items that show/hide elements
            // sessionStorage.removeItem('showDistribution');
            // sessionStorage.removeItem('showWaveform');
            // sessionStorage.removeItem('showSliceButtons');
            sessionStorage.setItem('showWaveform', 'false');
            sessionStorage.setItem('showSliceButtons', 'false');
            sessionStorage.setItem('showDistribution', 'false');
        }

        // Load existing waveform if available
        {% if show_waveform %}
        window.addEventListener('load', function() {
            loadExistingWaveform();
        });
        {% endif %}

        function startNewRecording() {
            // Reset animation state
            resetAnimationState();
            
            // Reset the interface for new recording
            if(recordBtn)
                recordBtn.style.display = 'block';
            loadBtn.style.display = 'inline-block';
            initialInfobox.style.display = 'block';

            // if (newRecordingBtn) newRecordingBtn.style.display = 'inline-block';
            if (clearBtn) clearBtn.style.display = 'none';
            waveformContainer.style.display = 'none';
            status.style.display = 'none';
            sliceStatus.style.display = 'none';
            
            // Clear slice status interval
            if (sliceStatusInterval) {
                clearInterval(sliceStatusInterval);
                sliceStatusInterval = null;
            }
            
            // Start new recording
            startRecording();
        }

        function loadExistingWaveform() {
            fetch('/get_waveform')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'ready') {
                        displayWaveform(data);
                        // showStatus(`Recording complete! Duration: ${data.duration.toFixed(1)}s. Click on a section to zoom in.`, 'ready');
                        // showStatus(`Recording complete!`, 'ready');
                        startSliceStatusMonitoring();
                        
                        // Show paragraphs instantly if page is reloaded with existing waveform
                        document.querySelectorAll('.rev-box > *').forEach(p => {
                            p.classList.add('instant');
                        });
                    }
                });
        }

        

        function loadAudio() {
            sessionStorage.clear(); // Clear sessionStorage to reset state
            console.log('Loading audio file...');
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'audio/wav';
            input.onchange = function(event) {
                const file = event.target.files[0];
                showLoading(true,1); // Show loading animation

                if (file) {
                    showStatus('Uploading audio file...', 'loading');
                    
                    const formData = new FormData();
                    formData.append('audio_file', file);  // Send the actual file, not just the name

                    fetch('/upload_audio', {  // Changed endpoint name for clarity
                        method: 'POST',
                        body: formData  // Don't set Content-Type header - let browser set it with boundary
                    })
                    .then(response => {
                        if (!response.ok) {
                            showLoading(false,1); // Hide loading animation
                            throw new Error('Network response was not ok');
                        }
                        
                        return response.json();
                    })
                    .then(data => {
                        console.log('Audio file uploaded:', data);
                        showLoading(false,1); // Hide loading animation
                        if (data.status === 'success') {
                            showStatus(`Loaded audio file: ${file.name}`, 'ready');
                            loadBtn.style.display = 'none';
                            if (recordBtn)
                                recordBtn.style.display = 'none';
                            initialInfobox.style.display = 'none';
                            if (clearBtn)
                                clearBtn.style.display = 'inline-block';
                            finishRecording();
                        } else {
                            showStatus(`Error: ${data.message}`, 'error');
                        }
                    })
                    .catch(error => {
                        console.error('Error uploading audio file:', error);
                        showStatus('Error loading audio file.', 'error');
                    });
                }
            };
            input.click();
        }

        function startRecording() {
            if (isRecording) return;

            isRecording = true;
            if (recordBtn)
                recordBtn.style.display = 'none';
            loadBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
            timer.style.display = 'block';
            waveformContainer.style.display = 'none';
            // if (newRecordingBtn) newRecordingBtn.style.display = 'none';
            
            showStatus('Recording in progress... Click Stop when finished.', 'recording');

            // Start recording
            fetch('/start_recording', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    console.log('Recording started:', data);
                    startTimer();
                });
        }

        function stopRecording() {
            if (!isRecording) return;

            fetch('/stop_recording', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    console.log('Recording stopped:', data);
                    finishRecording();
                });
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                fetch('/recording_status')
                    .then(response => response.json())
                    .then(data => {
                        if (data.is_recording) {
                            timerDisplay.textContent = data.duration.toFixed(1) + 's';
                        }
                    });
            }, 100);
        }

        // function getBcgColor(startingColor){
        //     // const bcgcolor = 'background: radial-gradient(ellipse closest-side at center, \n\
        //     //             rgba(255, 255, 0, 0.4) 80%,     /* Full opacity at center */\n\
        //     //             rgba(255, 255, 0, 0) 100%      /* Completely transparent at edges */\n\
        //     //         );';

        //     console.log('Generating background color with starting color:', startingColor);
        //     let col = `radial-gradient(ellipse closest-side at center, ${addAlpha(startingColor, 1)} 80%, ${addAlpha(startingColor, 0)} 100% );`;

        //     console.log('Generated background color:', col);
        //     return col;
        // }

        function getBcgColor(startingColor){
            // console.log('Generating background color with starting color:', startingColor);
            // let col = `radial-gradient(ellipse closest-side at center, ${addAlpha(startingColor, 1)} 80%, ${addAlpha(startingColor, 0)} 100%)`;
            col = `radial-gradient(ellipse closest-side at center, ${addAlpha(startingColor, 0.7)} 20%, transparent 100%)`;
            // console.log('Generated background color:', col);
            return col;
        }

        function startSliceStatusMonitoring() {
            // sliceStatus.style.display = 'block'; //TODO: see whether to enable this again
            sliceStatusInterval = setInterval(() => {
                fetch('/slice_status')
                    .then(response => response.json())
                    .then(data => {
                        if (data.computing) {
                            sliceStatus.className = 'slice-status computing';
                            sliceStatusText.textContent = 'Computing detailed slice views...';
                            updateSliceButtonsStatus('computing');
                        } else if (data.completed) {
                            sliceStatus.className = 'slice-status completed';
                            sliceStatusText.textContent = 'All slice views ready! Click any section to zoom.';
                            updateSliceButtonsStatus('ready');
                            clearInterval(sliceStatusInterval);
                            sliceStatusInterval = null;
                        }
                    })
                    .catch(error => {
                        console.error('Error checking slice status:', error);
                    });
            }, 1000);
        }

        function updateSliceButtonsStatus(status) {
            const sliceButtons = document.querySelectorAll('.slice-button');
            sliceButtons.forEach(btn => {
                btn.className = `slice-button ${status}`;
                if (status === 'computing') {
                    btn.title = 'Computing detailed view...';
                } else if (status === 'ready') {
                    btn.title = 'Click to view detailed slice (precomputed)';
                }
            });
        }

        function finishRecording() {

            clearInterval(timerInterval);
            isRecording = false;
            if (recordBtn)
                recordBtn.style.display = 'none';
            stopBtn.style.display = 'none';
            timer.style.display = 'none';
            
            // Make it so the status cycles between funny messages describing a process going on
            // Example: planting audio samples, watching the soundscape, trimming the waveform leaves, etc.
            // showStatus('', 'processing');

            
            fetch('/compute_waveform')
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'ready') {
                        displayWaveform(data);
                        showStatus(`Recording complete! Duration: ${data.duration.toFixed(1)}s. Click on a section to zoom in.`, 'ready');
                        if (clearBtn) clearBtn.style.display = 'inline-block';
                        
                        // Start monitoring slice computation
                        startSliceStatusMonitoring();
                        
                        if (clearBtn) 
                            clearBtn.style.display = 'inline-block';

                        showStatus(`Recording complete!`, 'ready');
                        
                        // Start the gradual unveiling animation
                        setTimeout(() => {
                            startGradualUnveiling();
                        }, 1000); // Start after 1 second delay
                    }
                    else {
                        showStatus(`Error: ${data.message}`, 'error');
                    }
                });
        }

        function addAlpha(color, opacity) {
            // coerce values so it is between 0 and 1.
            var _opacity = Math.round(Math.min(Math.max(opacity ?? 1, 0), 1) * 255);
            return color + _opacity.toString(16).toUpperCase();
        }

        function darker(color, amount) {
            // Ensure the color is in hex format
            if (color.startsWith('#')) {
                color = color.slice(1);
            }
            // Convert to RGB
            let r = parseInt(color.slice(0, 2), 16);
            let g = parseInt(color.slice(2, 4), 16);
            let b = parseInt(color.slice(4, 6), 16);

            // Darken the color
            r = Math.max(0, Math.min(255, r - amount));
            g = Math.max(0, Math.min(255, g - amount));
            b = Math.max(0, Math.min(255, b - amount));

            // Convert back to hex
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
        }

        function displayWaveform(data) {
            // console.log('Displaying waveform data:', data);
            waveformImg.src = 'data:image/png;base64,' + data.plot;
            sessionStorage.setItem('slicesLength', data.slices.length);
            console.log('!!!!!!!!!!!!!!!!SessionStorage slicesLength set to:', data.slices.length);
            if (data.slices.length > 1){
                emotionChartImg.src = 'data:image/png;base64,' + data.emotion_chart;
                // emotionChartImgBox.style.display = 'block';
                if (sessionStorage.getItem('showWaveform') === 'true') {
                    console.log('showWaveform is true, displaying emotion chart');
                    emotionChartImgBox.style.display = 'block';
                } else {
                    console.log('showWaveform is false, hiding emotion chart');
                    emotionChartImgBox.style.display = 'none';
                }
            }else{
                emotionChartImgBox.style.display = 'none';
            }
            if (waveformDuration)
                waveformDuration.textContent = data.duration.toFixed(1);
            recFilename.textContent = data.filename || 'No filename available';
            waveformContainer.style.display = 'block';

            recPlayer.style.display = 'block';
            recSource.src = data.audio_url || '';
            recPlayer.load();
            recPlayer.style.display = 'inline-block';

            status.style.display = 'none';

            overallEmotionPrint = data.overall_emotion.charAt(0).toUpperCase() + data.overall_emotion.slice(1);
            overallEmotionText.textContent = `${overallEmotionPrint || 'Unknown'}`;
            overallEmotionText.className =  `emocolor-darker-${data.overall_emotion.toLowerCase() || 'unknown'}`;
            // console.log('Overall Emotion Text set to :', overallEmotionText.textContent);
            counter = 0;
            for (const [emotion, prob] of Object.entries(data.overall_probabilities || {})) {
                // First letter of emotion capitalized
                emotionPrint = emotion.charAt(0).toUpperCase() + emotion.slice(1);
                let probString = `${emotionPrint}: ${(prob * 100).toFixed(2)}%`;
                if (overallEmotionProbs[counter]) {
                    overallEmotionProbs[counter].textContent = probString;
                }

                // Update bar chart
                const barLabel = document.getElementById(`bar_label_${counter}`);
                const barFill = document.getElementById(`bar_fill_${counter}`);
                const barPercentage = document.getElementById(`bar_percentage_${counter}`);
                
                if (barLabel && barFill && barPercentage) {
                    barLabel.textContent = emotionPrint;

                    if (overallEmotionPrint.toLowerCase() === emotionPrint.toLowerCase()) {
                        barLabel.style.fontWeight = 'bold';
                    } else {
                        barLabel.style.fontWeight = 'normal';
                    }
                    
                    // Animate the bar fill after a short delay
                    setTimeout(() => {
                        barFill.style.width = `${(prob * 100).toFixed(1)}%`;
                    }, 100 + (counter * 100)); // Stagger the animations
                    
                    barPercentage.textContent = `${(prob * 100).toFixed(1)}%`;
                }

                counter++;    
            }
            
            // overallEmotionProbs.textContent = `Probabilities: ${data.overall_probabilities ? JSON.stringify(data.overall_probabilities) : 'N/A'}`;
            
            
            // Add clickable slice areas
            const overlay = document.querySelector('.slice-overlay');
            
            // Remove existing slice buttons
            const existingButtons = overlay.querySelectorAll('.slice-button');
            // console.log('Removing', existingButtons.length, 'existing slice buttons'); 
            existingButtons.forEach(btn => btn.remove());
            
            // Add new slice buttons based on actual duration
            const numSlices = data.slices.length;

            // console.log(`Adding ${numSlices} slice buttons based on data`);
            
            // console.log('sessionStorage showSliceButtons:', sessionStorage.getItem('showSliceButtons'));
            // console.log("(sessionStorage.getItem('showSliceButtons')) && (sessionStorage.getItem('showSliceButtons') === 'true')", (sessionStorage.getItem('showSliceButtons')) && (sessionStorage.getItem('showSliceButtons') === 'true'));

            if (sessionStorage.getItem('showSliceButtons') === 'true') {
                document.getElementById('sliceStatus').style.display = 'block';
            } else {
                document.getElementById('sliceStatus').style.display = 'none';
            }

            let acc = 0
            for (let i = 0; i < numSlices; i++) {
                const sliceBtn = document.createElement('div');
                sliceBtn.className = 'slice-button';
                if ((sessionStorage.getItem('showSliceButtons')) && (sessionStorage.getItem('showSliceButtons') === 'true')) {
                    // console.log('Slice button', i, 'is visible based on sessionStorage');
                    sliceBtn.style.display = 'block';
                } else if (sessionStorage.getItem('showSliceButtons')) {
                    // console.log('Slice button', i, 'is hidden based on sessionStorage');
                    sliceBtn.style.display = 'none';
                } 

                // sliceBtn.style.display = 'none';
                // sliceBtn.style.backgroundColor = addAlpha(data.slices[i].color, 0.2) || 'rgba(255, 255, 0, 0.3)';

                let bg = getBcgColor(data.slices[i].color)
                sliceBtn.style.background = bg;
                // let testGradient1 = "radial-gradient(circle, red, blue)";
                // sliceBtn.style.background = testGradient1;

                let computedStyle = window.getComputedStyle(sliceBtn);
                const leftfact = 0.009;
                sliceBtn.style.left = (data.slices[i].left+leftfact-acc) * 100.0 + '%';

                const fact = 0.956;
                sliceBtn.style.width = data.slices[i].width * 100.0 * fact + '%';
                console.log(`Adding slice button ${i} with position: left ${sliceBtn.style.left}%, width ${sliceBtn.style.width}%`);
                sliceBtn.title = `Click to view slice ${data.slices[i].label}`;
                sliceBtn.addEventListener('click', () => {
                    // set lime_unveiled and lime_computed to false (sesisonStorage)
                    sessionStorage.setItem('lime_unveiled', 'false');
                    sessionStorage.setItem('lime_computed', 'false');
                    console.log(`Slice button ${i} clicked, navigating to /slice/${i}`);
                    window.location.href = `/slice/${i}`;
                });

                acc += data.slices[i].width - data.slices[i].width * fact; // Accumulate width for next slice button

                

                // Add event listener for hover effect
                sliceBtn.addEventListener('mouseover', () => {
                    if (!sliceBtn.classList.contains('computing')) {
                        sliceBtn.style.background = getBcgColor(darker(data.slices[i].color,70));
                    }
                });
                sliceBtn.addEventListener('mouseout', () => {
                    sliceBtn.style.background = getBcgColor(data.slices[i].color);
                });

                overlay.appendChild(sliceBtn);
            }
        }

        function showStatus(message, type) {

            if (type === 'processing') {
                // Make it so the status cycles between funny messages describing a process going on
                // Example: planting audio samples, watching the soundscape, trimming the waveform leaves, etc.
                let statusMessages = [
                    'Planting audio samples...',
                    'Watching the soundscape grow...',
                    'Trimming the waveform leaves...',
                    'Harvesting the audio crops...',
                    'Preparing the waveform for the town festival...',
                    'Gathering the sound waves...',
                    'Teaching frequencies to behave...',
                    'Herding stray decibels back into line...',
                    'Polishing the audio crystals...',
                    'Feeding the hungry algorithms...',
                    'Untangling the audio spaghetti...',
                    'Convincing the bits to cooperate...',
                    'Massaging the data into submission...',
                    'Whispering sweet nothings to the processor...',
                    'Counting sheep... er, samples...',
                    'Performing ancient audio rituals...',
                    'Consulting the digital oracle...',
                    'Negotiating with stubborn soundwaves...',
                    'Brewing a fresh batch of frequencies...',
                    'Tickling the microphone gently...',
                    'Searching for the perfect sine wave...',
                    'Calibrating the audio mood ring...',
                    'Asking the sound elves for help...',
                    'Reorganizing the frequency filing cabinet...',
                    'Dusting off the vintage algorithms...',
                    'Translating beeps into human...',
                    'Convincing the audio to take a bath...',
                    'Warming up the digital vocal cords...',
                    'Ironing out the audio wrinkles...',
                    'Giving the waveform a pep talk...',
                ];
                let statusIndex = 0;
                const statusInterval = setInterval(() => {
                    if (statusIndex < statusMessages.length) {
                        showStatus(statusMessages[statusIndex], 'recording');
                        statusIndex++;
                    } else {
                        clearInterval(statusInterval);
                        statusIndex = 0;
                    }
                }, 4000);
                return;
            }

            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
        }
    </script>
</body>
</html>